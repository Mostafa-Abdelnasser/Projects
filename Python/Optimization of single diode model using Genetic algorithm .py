# -*- coding: utf-8 -*-
"""GA_original.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/13arNkJpmgDQaMkCGBXI-RkatrRUQei0P
"""

import random
import math
import numpy as np
import matplotlib.pyplot as plt

# initialize I & V (measured values) ,vt
I=0
V=0
Vt=0.026369

# Define the evaluation function
def evaluate(individual):
    # Extract the five parameters from the individual
    Rs, Rsh, n, Isat, Iph = individual

    # Define the single diode model function
    def single_diode_model(V):
        return Iph - Isat * (np.exp((V + Rs * I) / (n * Vt)) - 1) - (V + Rs * I) / Rsh

    # Calculate the root mean squared error between the model and the data
    rmse = math.sqrt(sum((single_diode_model(V) - I)**2 for V, I in data) / len(data))

    return rmse

# Define the crossover function
def crossover(ind1, ind2):
    # Perform whole arithmetic recombination with a fixed value for alpha
    alpha = 0.5
    child1 = [alpha*x + (1-alpha)*y for x, y in zip(ind1, ind2)]
    child2 = [(1-alpha)*x + alpha*y for x, y in zip(ind1, ind2)]

    return child1, child2

# Define the mutation function
def mutate(individual):
    # Add random noise to each parameter
    individual = [x + random.gauss(0, 0.00000001) for x in individual]

    return individual,

# Set the random seed for reproducibility
#random.seed(42)

# Define the ranges for the five parameters
RANGE_LOW = [0.01, 0.001 , 1 , 0, 0]
RANGE_HIGH = [0.5, 100   ,  2, 0.5e-6, 1]

# Set the population size and number of generations
POP_SIZE = 100
NGEN = 200

# Set the percentages of best individuals and crossover and mutation probabilities
BEST_PCT =0.1
CROSSOVER_PCT = 0.8
MUTATION_PCT =0.1

# Create the initial population
pop = [[random.uniform(RANGE_LOW[i], RANGE_HIGH[i]) for i in range(5)] for _ in range(POP_SIZE)]

# Define some data tuples
data = [(0.52, 0.71), (0.52,0.72), (0.53, 0.76), (0.52459623, 0.70), (0.55, 0.65)]

loss_values = []

for gen in range(NGEN):
    # Evaluate the fitness of each individual in the population
    fitnesses = [evaluate(ind) for ind in pop]

    # Select individuals to breed based on their fitness rank
    selected = [pop[i] for i in sorted(range(len(fitnesses)), key=lambda i: fitnesses[i])[:int(BEST_PCT*POP_SIZE)]]

    # Create the next generation by breeding selected individuals
    children = []
    while len(children) < POP_SIZE:
        # Choose two parents randomly from the selected individuals
        parents = random.sample(selected, k=2)

        # Perform crossover with a fixed probability
        if random.random() < CROSSOVER_PCT:
            child1, child2 = crossover(parents[0], parents[1])
        else:
            child1, child2 = parents

        # Mutate the offspring with a fixed probability
        if random.random() < MUTATION_PCT:
            child1 = mutate(child1)[0]
        if random.random() < MUTATION_PCT:
            child2 = mutate(child2)[0]

        children.extend([child1, child2])

    # Replace the current population with the next generation
    pop = children[:POP_SIZE]

    # Extract the best individual from the final population
    best_individual = min(pop)

    loss_values.append(evaluate(best_individual))

# Print the best individual and its fitness value
print(f"Best individual: {best_individual}")
print(f"Best fitness value: {evaluate(best_individual)}")

plt.plot(loss_values)
plt.title('Loss vs Generation')
plt.xlabel('Generation')
plt.ylabel('Loss')
plt.show()